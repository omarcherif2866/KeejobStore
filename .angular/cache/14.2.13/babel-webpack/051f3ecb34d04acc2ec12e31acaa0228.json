{"ast":null,"code":"var rt = Object.defineProperty,\n    st = Object.defineProperties;\nvar nt = Object.getOwnPropertyDescriptors;\nvar F = Object.getOwnPropertySymbols;\nvar xe = Object.prototype.hasOwnProperty,\n    be = Object.prototype.propertyIsEnumerable;\n\nvar _e = (e, t, r) => t in e ? rt(e, t, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: r\n}) : e[t] = r,\n    h = (e, t) => {\n  for (var r in t || (t = {})) xe.call(t, r) && _e(e, r, t[r]);\n\n  if (F) for (var r of F(t)) be.call(t, r) && _e(e, r, t[r]);\n  return e;\n},\n    $ = (e, t) => st(e, nt(t));\n\nvar v = (e, t) => {\n  var r = {};\n\n  for (var s in e) xe.call(e, s) && t.indexOf(s) < 0 && (r[s] = e[s]);\n\n  if (e != null && F) for (var s of F(e)) t.indexOf(s) < 0 && be.call(e, s) && (r[s] = e[s]);\n  return r;\n};\n\nimport { deepMerge as it } from \"@primeuix/utils/object\";\n\nfunction ke(...e) {\n  return it(...e);\n}\n\nimport { deepMerge as $t } from \"@primeuix/utils/object\";\nimport { EventBus as ot } from \"@primeuix/utils/eventbus\";\nvar at = ot(),\n    N = at;\nimport { getKeyValue as lt, isArray as ct, isNotEmpty as mt, isNumber as se, isObject as $e, isString as P, matchRegex as J, toKebabCase as ut } from \"@primeuix/utils/object\";\nvar k = /{([^}]*)}/g,\n    ne = /(\\d+\\s+[\\+\\-\\*\\/]\\s+\\d+)/g,\n    ie = /var\\([^)]+\\)/g;\n\nfunction oe(e) {\n  return P(e) ? e.replace(/[A-Z]/g, (t, r) => r === 0 ? t : \".\" + t.toLowerCase()).toLowerCase() : e;\n}\n\nfunction Lt(e, t) {\n  ct(e) ? e.push(...(t || [])) : $e(e) && Object.assign(e, t);\n}\n\nfunction ve(e) {\n  return $e(e) && e.hasOwnProperty(\"$value\") && e.hasOwnProperty(\"$type\") ? e.$value : e;\n}\n\nfunction At(e, t = \"\") {\n  return [\"opacity\", \"z-index\", \"line-height\", \"font-weight\", \"flex\", \"flex-grow\", \"flex-shrink\", \"order\"].some(s => t.endsWith(s)) ? e : `${e}`.trim().split(\" \").map(a => se(a) ? `${a}px` : a).join(\" \");\n}\n\nfunction dt(e) {\n  return e.replaceAll(/ /g, \"\").replace(/[^\\w]/g, \"-\");\n}\n\nfunction Q(e = \"\", t = \"\") {\n  return dt(`${P(e, !1) && P(t, !1) ? `${e}-` : e}${t}`);\n}\n\nfunction ae(e = \"\", t = \"\") {\n  return `--${Q(e, t)}`;\n}\n\nfunction ht(e = \"\") {\n  let t = (e.match(/{/g) || []).length,\n      r = (e.match(/}/g) || []).length;\n  return (t + r) % 2 !== 0;\n}\n\nfunction Y(e, t = \"\", r = \"\", s = [], i) {\n  if (P(e)) {\n    let a = e.trim();\n    if (ht(a)) return;\n\n    if (J(a, k)) {\n      let n = a.replaceAll(k, l => {\n        let c = l.replace(/{|}/g, \"\").split(\".\").filter(m => !s.some(d => J(m, d)));\n        return `var(${ae(r, ut(c.join(\"-\")))}${mt(i) ? `, ${i}` : \"\"})`;\n      });\n      return J(n.replace(ie, \"0\"), ne) ? `calc(${n})` : n;\n    }\n\n    return a;\n  } else if (se(e)) return e;\n}\n\nfunction Dt(e = {}, t) {\n  if (P(t)) {\n    let r = t.trim();\n    return J(r, k) ? r.replaceAll(k, s => lt(e, s.replace(/{|}/g, \"\"))) : r;\n  } else if (se(t)) return t;\n}\n\nfunction Re(e, t, r) {\n  P(t, !1) && e.push(`${t}:${r};`);\n}\n\nfunction C(e, t) {\n  return e ? `${e}{${t}}` : \"\";\n}\n\nfunction le(e, t) {\n  if (e.indexOf(\"dt(\") === -1) return e;\n\n  function r(n, l) {\n    let o = [],\n        c = 0,\n        m = \"\",\n        d = null,\n        u = 0;\n\n    for (; c <= n.length;) {\n      let g = n[c];\n\n      if ((g === '\"' || g === \"'\" || g === \"`\") && n[c - 1] !== \"\\\\\" && (d = d === g ? null : g), !d && (g === \"(\" && u++, g === \")\" && u--, (g === \",\" || c === n.length) && u === 0)) {\n        let f = m.trim();\n        f.startsWith(\"dt(\") ? o.push(le(f, l)) : o.push(s(f)), m = \"\", c++;\n        continue;\n      }\n\n      g !== void 0 && (m += g), c++;\n    }\n\n    return o;\n  }\n\n  function s(n) {\n    let l = n[0];\n    if ((l === '\"' || l === \"'\" || l === \"`\") && n[n.length - 1] === l) return n.slice(1, -1);\n    let o = Number(n);\n    return isNaN(o) ? n : o;\n  }\n\n  let i = [],\n      a = [];\n\n  for (let n = 0; n < e.length; n++) if (e[n] === \"d\" && e.slice(n, n + 3) === \"dt(\") a.push(n), n += 2;else if (e[n] === \")\" && a.length > 0) {\n    let l = a.pop();\n    a.length === 0 && i.push([l, n]);\n  }\n\n  if (!i.length) return e;\n\n  for (let n = i.length - 1; n >= 0; n--) {\n    let [l, o] = i[n],\n        c = e.slice(l + 3, o),\n        m = r(c, t),\n        d = t(...m);\n    e = e.slice(0, l) + d + e.slice(o + 1);\n  }\n\n  return e;\n}\n\nimport { isEmpty as kt, isNotEmpty as _, isObject as he, matchRegex as we, minifyCSS as Oe, resolve as ee } from \"@primeuix/utils/object\";\n\nfunction Te(e) {\n  return e.length === 4 ? `#${e[1]}${e[1]}${e[2]}${e[2]}${e[3]}${e[3]}` : e;\n}\n\nfunction Ne(e) {\n  let t = parseInt(e.substring(1), 16),\n      r = t >> 16 & 255,\n      s = t >> 8 & 255,\n      i = t & 255;\n  return {\n    r,\n    g: s,\n    b: i\n  };\n}\n\nfunction gt(e, t, r) {\n  return `#${e.toString(16).padStart(2, \"0\")}${t.toString(16).padStart(2, \"0\")}${r.toString(16).padStart(2, \"0\")}`;\n}\n\nvar D = (e, t, r) => {\n  e = Te(e), t = Te(t);\n  let a = (r / 100 * 2 - 1 + 1) / 2,\n      n = 1 - a,\n      l = Ne(e),\n      o = Ne(t),\n      c = Math.round(l.r * a + o.r * n),\n      m = Math.round(l.g * a + o.g * n),\n      d = Math.round(l.b * a + o.b * n);\n  return gt(c, m, d);\n};\n\nimport { matchRegex as pt } from \"@primeuix/utils\";\n\nvar ce = (e, t) => D(\"#000000\", e, t);\n\nvar me = (e, t) => D(\"#ffffff\", e, t);\n\nvar Ce = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950],\n    ft = e => {\n  if (pt(e, k)) {\n    let t = e.replace(/{|}/g, \"\");\n    return Ce.reduce((r, s) => (r[s] = `{${t}.${s}}`, r), {});\n  }\n\n  return typeof e == \"string\" ? Ce.reduce((t, r, s) => (t[r] = s <= 5 ? me(e, (5 - s) * 19) : ce(e, (s - 5) * 15), t), {}) : e;\n};\n\nimport { resolve as Ee } from \"@primeuix/utils\";\nimport { isEmpty as yt, matchRegex as St } from \"@primeuix/utils/object\";\n\nvar rr = e => {\n  var a;\n  let t = S.getTheme(),\n      r = ue(t, e, void 0, \"variable\"),\n      s = (a = r == null ? void 0 : r.match(/--[\\w-]+/g)) == null ? void 0 : a[0],\n      i = ue(t, e, void 0, \"value\");\n  return {\n    name: s,\n    variable: r,\n    value: i\n  };\n},\n    E = (...e) => ue(S.getTheme(), ...e),\n    ue = (e = {}, t, r, s) => {\n  if (t) {\n    let {\n      variable: i,\n      options: a\n    } = S.defaults || {},\n        {\n      prefix: n,\n      transform: l\n    } = (e == null ? void 0 : e.options) || a || {},\n        o = St(t, k) ? t : `{${t}}`;\n    return s === \"value\" || yt(s) && l === \"strict\" ? S.getTokenValue(t) : Y(o, void 0, n, [i.excludedKeyRegex], r);\n  }\n\n  return \"\";\n};\n\nfunction ar(e, ...t) {\n  if (e instanceof Array) {\n    let r = e.reduce((s, i, a) => {\n      var n;\n      return s + i + ((n = Ee(t[a], {\n        dt: E\n      })) != null ? n : \"\");\n    }, \"\");\n    return le(r, E);\n  }\n\n  return Ee(e, {\n    dt: E\n  });\n}\n\nimport { mergeKeys as Pe } from \"@primeuix/utils/object\";\n\nvar w = (e = {}) => {\n  let {\n    preset: t,\n    options: r\n  } = e;\n  return {\n    preset(s) {\n      return t = t ? Pe(t, s) : s, this;\n    },\n\n    options(s) {\n      return r = r ? h(h({}, r), s) : s, this;\n    },\n\n    primaryPalette(s) {\n      let {\n        semantic: i\n      } = t || {};\n      return t = $(h({}, t), {\n        semantic: $(h({}, i), {\n          primary: s\n        })\n      }), this;\n    },\n\n    surfacePalette(s) {\n      var o, c;\n      let {\n        semantic: i\n      } = t || {},\n          a = s && Object.hasOwn(s, \"light\") ? s.light : s,\n          n = s && Object.hasOwn(s, \"dark\") ? s.dark : s,\n          l = {\n        colorScheme: {\n          light: h(h({}, (o = i == null ? void 0 : i.colorScheme) == null ? void 0 : o.light), !!a && {\n            surface: a\n          }),\n          dark: h(h({}, (c = i == null ? void 0 : i.colorScheme) == null ? void 0 : c.dark), !!n && {\n            surface: n\n          })\n        }\n      };\n      return t = $(h({}, t), {\n        semantic: h(h({}, i), l)\n      }), this;\n    },\n\n    define({\n      useDefaultPreset: s = !1,\n      useDefaultOptions: i = !1\n    } = {}) {\n      return {\n        preset: s ? S.getPreset() : t,\n        options: i ? S.getOptions() : r\n      };\n    },\n\n    update({\n      mergePresets: s = !0,\n      mergeOptions: i = !0\n    } = {}) {\n      let a = {\n        preset: s ? Pe(S.getPreset(), t) : t,\n        options: i ? h(h({}, S.getOptions()), r) : r\n      };\n      return S.setTheme(a), a;\n    },\n\n    use(s) {\n      let i = this.define(s);\n      return S.setTheme(i), i;\n    }\n\n  };\n};\n\nimport { isObject as _t, matchRegex as xt, toKebabCase as bt } from \"@primeuix/utils/object\";\n\nfunction de(e, t = {}) {\n  let r = S.defaults.variable,\n      {\n    prefix: s = r.prefix,\n    selector: i = r.selector,\n    excludedKeyRegex: a = r.excludedKeyRegex\n  } = t,\n      n = [],\n      l = [],\n      o = [{\n    node: e,\n    path: s\n  }];\n\n  for (; o.length;) {\n    let {\n      node: m,\n      path: d\n    } = o.pop();\n\n    for (let u in m) {\n      let g = m[u],\n          f = ve(g),\n          p = xt(u, a) ? Q(d) : Q(d, bt(u));\n      if (_t(f)) o.push({\n        node: f,\n        path: p\n      });else {\n        let y = ae(p),\n            R = Y(f, p, s, [a]);\n        Re(l, y, R);\n        let T = p;\n        s && T.startsWith(s + \"-\") && (T = T.slice(s.length + 1)), n.push(T.replace(/-/g, \".\"));\n      }\n    }\n  }\n\n  let c = l.join(\"\");\n  return {\n    value: l,\n    tokens: n,\n    declarations: c,\n    css: C(i, c)\n  };\n}\n\nvar b = {\n  regex: {\n    rules: {\n      class: {\n        pattern: /^\\.([a-zA-Z][\\w-]*)$/,\n\n        resolve(e) {\n          return {\n            type: \"class\",\n            selector: e,\n            matched: this.pattern.test(e.trim())\n          };\n        }\n\n      },\n      attr: {\n        pattern: /^\\[(.*)\\]$/,\n\n        resolve(e) {\n          return {\n            type: \"attr\",\n            selector: `:root${e},:host${e}`,\n            matched: this.pattern.test(e.trim())\n          };\n        }\n\n      },\n      media: {\n        pattern: /^@media (.*)$/,\n\n        resolve(e) {\n          return {\n            type: \"media\",\n            selector: e,\n            matched: this.pattern.test(e.trim())\n          };\n        }\n\n      },\n      system: {\n        pattern: /^system$/,\n\n        resolve(e) {\n          return {\n            type: \"system\",\n            selector: \"@media (prefers-color-scheme: dark)\",\n            matched: this.pattern.test(e.trim())\n          };\n        }\n\n      },\n      custom: {\n        resolve(e) {\n          return {\n            type: \"custom\",\n            selector: e,\n            matched: !0\n          };\n        }\n\n      }\n    },\n\n    resolve(e) {\n      let t = Object.keys(this.rules).filter(r => r !== \"custom\").map(r => this.rules[r]);\n      return [e].flat().map(r => {\n        var s;\n        return (s = t.map(i => i.resolve(r)).find(i => i.matched)) != null ? s : this.rules.custom.resolve(r);\n      });\n    }\n\n  },\n\n  _toVariables(e, t) {\n    return de(e, {\n      prefix: t == null ? void 0 : t.prefix\n    });\n  },\n\n  getCommon({\n    name: e = \"\",\n    theme: t = {},\n    params: r,\n    set: s,\n    defaults: i\n  }) {\n    var R, T, j, O, M, z, V;\n    let {\n      preset: a,\n      options: n\n    } = t,\n        l,\n        o,\n        c,\n        m,\n        d,\n        u,\n        g;\n\n    if (_(a) && n.transform !== \"strict\") {\n      let {\n        primitive: L,\n        semantic: te,\n        extend: re\n      } = a,\n          f = te || {},\n          {\n        colorScheme: K\n      } = f,\n          A = v(f, [\"colorScheme\"]),\n          x = re || {},\n          {\n        colorScheme: X\n      } = x,\n          G = v(x, [\"colorScheme\"]),\n          p = K || {},\n          {\n        dark: U\n      } = p,\n          B = v(p, [\"dark\"]),\n          y = X || {},\n          {\n        dark: I\n      } = y,\n          H = v(y, [\"dark\"]),\n          W = _(L) ? this._toVariables({\n        primitive: L\n      }, n) : {},\n          q = _(A) ? this._toVariables({\n        semantic: A\n      }, n) : {},\n          Z = _(B) ? this._toVariables({\n        light: B\n      }, n) : {},\n          pe = _(U) ? this._toVariables({\n        dark: U\n      }, n) : {},\n          fe = _(G) ? this._toVariables({\n        semantic: G\n      }, n) : {},\n          ye = _(H) ? this._toVariables({\n        light: H\n      }, n) : {},\n          Se = _(I) ? this._toVariables({\n        dark: I\n      }, n) : {},\n          [Me, ze] = [(R = W.declarations) != null ? R : \"\", W.tokens],\n          [Ke, Xe] = [(T = q.declarations) != null ? T : \"\", q.tokens || []],\n          [Ge, Ue] = [(j = Z.declarations) != null ? j : \"\", Z.tokens || []],\n          [Be, Ie] = [(O = pe.declarations) != null ? O : \"\", pe.tokens || []],\n          [He, We] = [(M = fe.declarations) != null ? M : \"\", fe.tokens || []],\n          [qe, Ze] = [(z = ye.declarations) != null ? z : \"\", ye.tokens || []],\n          [Fe, Je] = [(V = Se.declarations) != null ? V : \"\", Se.tokens || []];\n      l = this.transformCSS(e, Me, \"light\", \"variable\", n, s, i), o = ze;\n      let Qe = this.transformCSS(e, `${Ke}${Ge}`, \"light\", \"variable\", n, s, i),\n          Ye = this.transformCSS(e, `${Be}`, \"dark\", \"variable\", n, s, i);\n      c = `${Qe}${Ye}`, m = [...new Set([...Xe, ...Ue, ...Ie])];\n      let et = this.transformCSS(e, `${He}${qe}color-scheme:light`, \"light\", \"variable\", n, s, i),\n          tt = this.transformCSS(e, `${Fe}color-scheme:dark`, \"dark\", \"variable\", n, s, i);\n      d = `${et}${tt}`, u = [...new Set([...We, ...Ze, ...Je])], g = ee(a.css, {\n        dt: E\n      });\n    }\n\n    return {\n      primitive: {\n        css: l,\n        tokens: o\n      },\n      semantic: {\n        css: c,\n        tokens: m\n      },\n      global: {\n        css: d,\n        tokens: u\n      },\n      style: g\n    };\n  },\n\n  getPreset({\n    name: e = \"\",\n    preset: t = {},\n    options: r,\n    params: s,\n    set: i,\n    defaults: a,\n    selector: n\n  }) {\n    var f, x, p;\n    let l, o, c;\n\n    if (_(t) && r.transform !== \"strict\") {\n      let y = e.replace(\"-directive\", \"\"),\n          m = t,\n          {\n        colorScheme: R,\n        extend: T,\n        css: j\n      } = m,\n          O = v(m, [\"colorScheme\", \"extend\", \"css\"]),\n          d = T || {},\n          {\n        colorScheme: M\n      } = d,\n          z = v(d, [\"colorScheme\"]),\n          u = R || {},\n          {\n        dark: V\n      } = u,\n          L = v(u, [\"dark\"]),\n          g = M || {},\n          {\n        dark: te\n      } = g,\n          re = v(g, [\"dark\"]),\n          K = _(O) ? this._toVariables({\n        [y]: h(h({}, O), z)\n      }, r) : {},\n          A = _(L) ? this._toVariables({\n        [y]: h(h({}, L), re)\n      }, r) : {},\n          X = _(V) ? this._toVariables({\n        [y]: h(h({}, V), te)\n      }, r) : {},\n          [G, U] = [(f = K.declarations) != null ? f : \"\", K.tokens || []],\n          [B, I] = [(x = A.declarations) != null ? x : \"\", A.tokens || []],\n          [H, W] = [(p = X.declarations) != null ? p : \"\", X.tokens || []],\n          q = this.transformCSS(y, `${G}${B}`, \"light\", \"variable\", r, i, a, n),\n          Z = this.transformCSS(y, H, \"dark\", \"variable\", r, i, a, n);\n      l = `${q}${Z}`, o = [...new Set([...U, ...I, ...W])], c = ee(j, {\n        dt: E\n      });\n    }\n\n    return {\n      css: l,\n      tokens: o,\n      style: c\n    };\n  },\n\n  getPresetC({\n    name: e = \"\",\n    theme: t = {},\n    params: r,\n    set: s,\n    defaults: i\n  }) {\n    var o;\n    let {\n      preset: a,\n      options: n\n    } = t,\n        l = (o = a == null ? void 0 : a.components) == null ? void 0 : o[e];\n    return this.getPreset({\n      name: e,\n      preset: l,\n      options: n,\n      params: r,\n      set: s,\n      defaults: i\n    });\n  },\n\n  getPresetD({\n    name: e = \"\",\n    theme: t = {},\n    params: r,\n    set: s,\n    defaults: i\n  }) {\n    var c, m;\n    let a = e.replace(\"-directive\", \"\"),\n        {\n      preset: n,\n      options: l\n    } = t,\n        o = ((c = n == null ? void 0 : n.components) == null ? void 0 : c[a]) || ((m = n == null ? void 0 : n.directives) == null ? void 0 : m[a]);\n    return this.getPreset({\n      name: a,\n      preset: o,\n      options: l,\n      params: r,\n      set: s,\n      defaults: i\n    });\n  },\n\n  applyDarkColorScheme(e) {\n    return !(e.darkModeSelector === \"none\" || e.darkModeSelector === !1);\n  },\n\n  getColorSchemeOption(e, t) {\n    var r;\n    return this.applyDarkColorScheme(e) ? this.regex.resolve(e.darkModeSelector === !0 ? t.options.darkModeSelector : (r = e.darkModeSelector) != null ? r : t.options.darkModeSelector) : [];\n  },\n\n  getLayerOrder(e, t = {}, r, s) {\n    let {\n      cssLayer: i\n    } = t;\n    return i ? `@layer ${ee(i.order || i.name || \"primeui\", r)}` : \"\";\n  },\n\n  getCommonStyleSheet({\n    name: e = \"\",\n    theme: t = {},\n    params: r,\n    props: s = {},\n    set: i,\n    defaults: a\n  }) {\n    let n = this.getCommon({\n      name: e,\n      theme: t,\n      params: r,\n      set: i,\n      defaults: a\n    }),\n        l = Object.entries(s).reduce((o, [c, m]) => o.push(`${c}=\"${m}\"`) && o, []).join(\" \");\n    return Object.entries(n || {}).reduce((o, [c, m]) => {\n      if (he(m) && Object.hasOwn(m, \"css\")) {\n        let d = Oe(m.css),\n            u = `${c}-variables`;\n        o.push(`<style type=\"text/css\" data-primevue-style-id=\"${u}\" ${l}>${d}</style>`);\n      }\n\n      return o;\n    }, []).join(\"\");\n  },\n\n  getStyleSheet({\n    name: e = \"\",\n    theme: t = {},\n    params: r,\n    props: s = {},\n    set: i,\n    defaults: a\n  }) {\n    var c;\n    let n = {\n      name: e,\n      theme: t,\n      params: r,\n      set: i,\n      defaults: a\n    },\n        l = (c = e.includes(\"-directive\") ? this.getPresetD(n) : this.getPresetC(n)) == null ? void 0 : c.css,\n        o = Object.entries(s).reduce((m, [d, u]) => m.push(`${d}=\"${u}\"`) && m, []).join(\" \");\n    return l ? `<style type=\"text/css\" data-primevue-style-id=\"${e}-variables\" ${o}>${Oe(l)}</style>` : \"\";\n  },\n\n  createTokens(e = {}, t, r = \"\", s = \"\", i = {}) {\n    let a = function (l, o = {}, c = []) {\n      if (c.includes(this.path)) return console.warn(`Circular reference detected at ${this.path}`), {\n        colorScheme: l,\n        path: this.path,\n        paths: o,\n        value: void 0\n      };\n      c.push(this.path), o.name = this.path, o.binding || (o.binding = {});\n      let m = this.value;\n\n      if (typeof this.value == \"string\" && k.test(this.value)) {\n        let u = this.value.trim().replace(k, g => {\n          var y;\n          let f = g.slice(1, -1),\n              x = this.tokens[f];\n          if (!x) return console.warn(`Token not found for path: ${f}`), \"__UNRESOLVED__\";\n          let p = x.computed(l, o, c);\n          return Array.isArray(p) && p.length === 2 ? `light-dark(${p[0].value},${p[1].value})` : (y = p == null ? void 0 : p.value) != null ? y : \"__UNRESOLVED__\";\n        });\n        m = ne.test(u.replace(ie, \"0\")) ? `calc(${u})` : u;\n      }\n\n      return kt(o.binding) && delete o.binding, c.pop(), {\n        colorScheme: l,\n        path: this.path,\n        paths: o,\n        value: m.includes(\"__UNRESOLVED__\") ? void 0 : m\n      };\n    },\n        n = (l, o, c) => {\n      Object.entries(l).forEach(([m, d]) => {\n        let u = we(m, t.variable.excludedKeyRegex) ? o : o ? `${o}.${oe(m)}` : oe(m),\n            g = c ? `${c}.${m}` : m;\n        he(d) ? n(d, u, g) : (i[u] || (i[u] = {\n          paths: [],\n          computed: (f, x = {}, p = []) => {\n            if (i[u].paths.length === 1) return i[u].paths[0].computed(i[u].paths[0].scheme, x.binding, p);\n            if (f && f !== \"none\") for (let y = 0; y < i[u].paths.length; y++) {\n              let R = i[u].paths[y];\n              if (R.scheme === f) return R.computed(f, x.binding, p);\n            }\n            return i[u].paths.map(y => y.computed(y.scheme, x[y.scheme], p));\n          }\n        }), i[u].paths.push({\n          path: g,\n          value: d,\n          scheme: g.includes(\"colorScheme.light\") ? \"light\" : g.includes(\"colorScheme.dark\") ? \"dark\" : \"none\",\n          computed: a,\n          tokens: i\n        }));\n      });\n    };\n\n    return n(e, r, s), i;\n  },\n\n  getTokenValue(e, t, r) {\n    var l;\n\n    let i = (o => o.split(\".\").filter(m => !we(m.toLowerCase(), r.variable.excludedKeyRegex)).join(\".\"))(t),\n        a = t.includes(\"colorScheme.light\") ? \"light\" : t.includes(\"colorScheme.dark\") ? \"dark\" : void 0,\n        n = [(l = e[i]) == null ? void 0 : l.computed(a)].flat().filter(o => o);\n\n    return n.length === 1 ? n[0].value : n.reduce((o = {}, c) => {\n      let u = c,\n          {\n        colorScheme: m\n      } = u,\n          d = v(u, [\"colorScheme\"]);\n      return o[m] = d, o;\n    }, void 0);\n  },\n\n  getSelectorRule(e, t, r, s) {\n    return r === \"class\" || r === \"attr\" ? C(_(t) ? `${e}${t},${e} ${t}` : e, s) : C(e, C(t != null ? t : \":root,:host\", s));\n  },\n\n  transformCSS(e, t, r, s, i = {}, a, n, l) {\n    if (_(t)) {\n      let {\n        cssLayer: o\n      } = i;\n\n      if (s !== \"style\") {\n        let c = this.getColorSchemeOption(i, n);\n        t = r === \"dark\" ? c.reduce((m, {\n          type: d,\n          selector: u\n        }) => (_(u) && (m += u.includes(\"[CSS]\") ? u.replace(\"[CSS]\", t) : this.getSelectorRule(u, l, d, t)), m), \"\") : C(l != null ? l : \":root,:host\", t);\n      }\n\n      if (o) {\n        let c = {\n          name: \"primeui\",\n          order: \"primeui\"\n        };\n        he(o) && (c.name = ee(o.name, {\n          name: e,\n          type: s\n        })), _(c.name) && (t = C(`@layer ${c.name}`, t), a == null || a.layerNames(c.name));\n      }\n\n      return t;\n    }\n\n    return \"\";\n  }\n\n};\nvar S = {\n  defaults: {\n    variable: {\n      prefix: \"p\",\n      selector: \":root,:host\",\n      excludedKeyRegex: /^(primitive|semantic|components|directives|variables|colorscheme|light|dark|common|root|states|extend|css)$/gi\n    },\n    options: {\n      prefix: \"p\",\n      darkModeSelector: \"system\",\n      cssLayer: !1\n    }\n  },\n  _theme: void 0,\n  _layerNames: new Set(),\n  _loadedStyleNames: new Set(),\n  _loadingStyles: new Set(),\n  _tokens: {},\n\n  update(e = {}) {\n    let {\n      theme: t\n    } = e;\n    t && (this._theme = $(h({}, t), {\n      options: h(h({}, this.defaults.options), t.options)\n    }), this._tokens = b.createTokens(this.preset, this.defaults), this.clearLoadedStyleNames());\n  },\n\n  get theme() {\n    return this._theme;\n  },\n\n  get preset() {\n    var e;\n    return ((e = this.theme) == null ? void 0 : e.preset) || {};\n  },\n\n  get options() {\n    var e;\n    return ((e = this.theme) == null ? void 0 : e.options) || {};\n  },\n\n  get tokens() {\n    return this._tokens;\n  },\n\n  getTheme() {\n    return this.theme;\n  },\n\n  setTheme(e) {\n    this.update({\n      theme: e\n    }), N.emit(\"theme:change\", e);\n  },\n\n  getPreset() {\n    return this.preset;\n  },\n\n  setPreset(e) {\n    this._theme = $(h({}, this.theme), {\n      preset: e\n    }), this._tokens = b.createTokens(e, this.defaults), this.clearLoadedStyleNames(), N.emit(\"preset:change\", e), N.emit(\"theme:change\", this.theme);\n  },\n\n  getOptions() {\n    return this.options;\n  },\n\n  setOptions(e) {\n    this._theme = $(h({}, this.theme), {\n      options: e\n    }), this.clearLoadedStyleNames(), N.emit(\"options:change\", e), N.emit(\"theme:change\", this.theme);\n  },\n\n  getLayerNames() {\n    return [...this._layerNames];\n  },\n\n  setLayerNames(e) {\n    this._layerNames.add(e);\n  },\n\n  getLoadedStyleNames() {\n    return this._loadedStyleNames;\n  },\n\n  isStyleNameLoaded(e) {\n    return this._loadedStyleNames.has(e);\n  },\n\n  setLoadedStyleName(e) {\n    this._loadedStyleNames.add(e);\n  },\n\n  deleteLoadedStyleName(e) {\n    this._loadedStyleNames.delete(e);\n  },\n\n  clearLoadedStyleNames() {\n    this._loadedStyleNames.clear();\n  },\n\n  getTokenValue(e) {\n    return b.getTokenValue(this.tokens, e, this.defaults);\n  },\n\n  getCommon(e = \"\", t) {\n    return b.getCommon({\n      name: e,\n      theme: this.theme,\n      params: t,\n      defaults: this.defaults,\n      set: {\n        layerNames: this.setLayerNames.bind(this)\n      }\n    });\n  },\n\n  getComponent(e = \"\", t) {\n    let r = {\n      name: e,\n      theme: this.theme,\n      params: t,\n      defaults: this.defaults,\n      set: {\n        layerNames: this.setLayerNames.bind(this)\n      }\n    };\n    return b.getPresetC(r);\n  },\n\n  getDirective(e = \"\", t) {\n    let r = {\n      name: e,\n      theme: this.theme,\n      params: t,\n      defaults: this.defaults,\n      set: {\n        layerNames: this.setLayerNames.bind(this)\n      }\n    };\n    return b.getPresetD(r);\n  },\n\n  getCustomPreset(e = \"\", t, r, s) {\n    let i = {\n      name: e,\n      preset: t,\n      options: this.options,\n      selector: r,\n      params: s,\n      defaults: this.defaults,\n      set: {\n        layerNames: this.setLayerNames.bind(this)\n      }\n    };\n    return b.getPreset(i);\n  },\n\n  getLayerOrderCSS(e = \"\") {\n    return b.getLayerOrder(e, this.options, {\n      names: this.getLayerNames()\n    }, this.defaults);\n  },\n\n  transformCSS(e = \"\", t, r = \"style\", s) {\n    return b.transformCSS(e, t, s, r, this.options, {\n      layerNames: this.setLayerNames.bind(this)\n    }, this.defaults);\n  },\n\n  getCommonStyleSheet(e = \"\", t, r = {}) {\n    return b.getCommonStyleSheet({\n      name: e,\n      theme: this.theme,\n      params: t,\n      props: r,\n      defaults: this.defaults,\n      set: {\n        layerNames: this.setLayerNames.bind(this)\n      }\n    });\n  },\n\n  getStyleSheet(e, t, r = {}) {\n    return b.getStyleSheet({\n      name: e,\n      theme: this.theme,\n      params: t,\n      props: r,\n      defaults: this.defaults,\n      set: {\n        layerNames: this.setLayerNames.bind(this)\n      }\n    });\n  },\n\n  onStyleMounted(e) {\n    this._loadingStyles.add(e);\n  },\n\n  onStyleUpdated(e) {\n    this._loadingStyles.add(e);\n  },\n\n  onStyleLoaded(e, {\n    name: t\n  }) {\n    this._loadingStyles.size && (this._loadingStyles.delete(t), N.emit(`theme:${t}:load`, e), !this._loadingStyles.size && N.emit(\"theme:load\"));\n  }\n\n};\n\nfunction Ve(...e) {\n  let t = $t(S.getPreset(), ...e);\n  return S.setPreset(t), t;\n}\n\nfunction Le(e) {\n  return w().primaryPalette(e).update().preset;\n}\n\nfunction Ae(e) {\n  return w().surfacePalette(e).update().preset;\n}\n\nimport { deepMerge as vt } from \"@primeuix/utils/object\";\n\nfunction De(...e) {\n  let t = vt(...e);\n  return S.setPreset(t), t;\n}\n\nfunction je(e) {\n  return w(e).update({\n    mergePresets: !1\n  });\n}\n\nimport { createStyleMarkup as Rt, isNotEmpty as Tt } from \"@primeuix/utils\";\nvar ge = class {\n  constructor({\n    attrs: t\n  } = {}) {\n    this._styles = new Map(), this._attrs = t || {};\n  }\n\n  get(t) {\n    return this._styles.get(t);\n  }\n\n  has(t) {\n    return this._styles.has(t);\n  }\n\n  delete(t) {\n    this._styles.delete(t);\n  }\n\n  clear() {\n    this._styles.clear();\n  }\n\n  add(t, r) {\n    if (Tt(r)) {\n      let s = {\n        name: t,\n        css: r,\n        attrs: this._attrs,\n        markup: Rt(r, this._attrs)\n      };\n\n      this._styles.set(t, $(h({}, s), {\n        element: this.createStyleElement(s)\n      }));\n    }\n  }\n\n  update() {}\n\n  getStyles() {\n    return this._styles;\n  }\n\n  getAllCSS() {\n    return [...this._styles.values()].map(t => t.css).filter(String);\n  }\n\n  getAllMarkup() {\n    return [...this._styles.values()].map(t => t.markup).filter(String);\n  }\n\n  getAllElements() {\n    return [...this._styles.values()].map(t => t.element);\n  }\n\n  createStyleElement(t = {}) {}\n\n},\n    Nt = ge;\nexport { rr as $dt, w as $t, ne as CALC_REGEX, k as EXPR_REGEX, Nt as StyleSheet, S as Theme, N as ThemeService, b as ThemeUtils, ie as VAR_REGEX, ar as css, ke as definePreset, E as dt, ue as dtwt, le as evaluateDtExpressions, Dt as getComputedValue, C as getRule, ae as getVariableName, Y as getVariableValue, ht as hasOddBraces, Lt as merge, D as mix, ft as palette, Re as setProperty, ce as shade, me as tint, dt as toNormalizePrefix, Q as toNormalizeVariable, oe as toTokenKey, At as toUnit, ve as toValue, de as toVariables, Ve as updatePreset, Le as updatePrimaryPalette, Ae as updateSurfacePalette, De as usePreset, je as useTheme }; //# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPathMatch = getPathMatch;\n\nvar _extends = require(\"@swc/helpers/lib/_extends.js\").default;\n\nvar _pathToRegexp = require(\"next/dist/compiled/path-to-regexp\");\n\nfunction getPathMatch(path, options) {\n  const keys = [];\n  const regexp = (0, _pathToRegexp).pathToRegexp(path, keys, {\n    delimiter: '/',\n    sensitive: false,\n    strict: options == null ? void 0 : options.strict\n  });\n  const matcher = (0, _pathToRegexp).regexpToFunction((options == null ? void 0 : options.regexModifier) ? new RegExp(options.regexModifier(regexp.source), regexp.flags) : regexp, keys);\n  /**\n  * A matcher function that will check if a given pathname matches the path\n  * given in the builder function. When the path does not match it will return\n  * `false` but if it does it will return an object with the matched params\n  * merged with the params provided in the second argument.\n  */\n\n  return (pathname, params) => {\n    const res = pathname == null ? false : matcher(pathname);\n\n    if (!res) {\n      return false;\n    }\n    /**\n    * If unnamed params are not allowed they must be removed from\n    * the matched parameters. path-to-regexp uses \"string\" for named and\n    * \"number\" for unnamed parameters.\n    */\n\n\n    if (options == null ? void 0 : options.removeUnnamedParams) {\n      for (const key of keys) {\n        if (typeof key.name === 'number') {\n          delete res.params[key.name];\n        }\n      }\n    }\n\n    return _extends({}, params, res.params);\n  };\n} //# sourceMappingURL=path-match.js.map","map":null,"metadata":{},"sourceType":"script"}